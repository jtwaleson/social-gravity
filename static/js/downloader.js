// Generated by CoffeeScript 1.3.3
(function() {
  var DownloadStatus, Downloader;

  DownloadStatus = (function() {

    function DownloadStatus(downloader, container) {
      var _this = this;
      this.downloader = downloader;
      this.div = $("<div>").addClass('download_status').css('display', 'none').appendTo(container);
      this.failed_count = 0;
      this.queue = $("<span>").addClass('queue');
      this.failed = $("<span>").addClass('failed');
      this.success = $("<span>").addClass('success');
      this.visual_insertion = $("<button>").click(function() {
        return downloader.visual_insert = !downloader.visual_insert;
      }).html('toggle insert tracer');
      this.stopstart = $("<button>").addClass("cancel").click(function() {
        _this.downloader.q.tasks = [];
        _this.downloader.to_load = {};
        _this.downloader.failed_downloads = 0;
        return _this.div.css('display', 'none');
      }).html('stop downloading');
      this.div.append(this.queue).append(this.failed).append(this.success).append(this.visual_insertion).append(this.stopstart);
      this.update();
    }

    DownloadStatus.prototype.update = function() {
      if (this.downloader.q.length() > 0) {
        this.div.css('display', 'inline');
        this.queue.text("queued: " + (this.downloader.q.length()));
        if (this.downloader.failed_downloads > 0) {
          this.failed.text("failed: " + this.downloader.failed_downloads + " (DAMN YOU TWITTER API)");
        } else {
          this.failed.text("failed: " + this.downloader.failed_downloads);
        }
        return this.success.text("success: " + ($(".friend").length));
      } else {
        return this.div.css('display', 'none');
      }
    };

    return DownloadStatus;

  })();

  Downloader = (function() {

    function Downloader() {
      var try_cache, try_pipes, try_twitter,
        _this = this;
      this.no_more_twitter_count = 0;
      this.no_more_twitter = false;
      this.no_more_pipes = false;
      this.failed_downloads = 0;
      this.to_load = {};
      this.btn = new Button(0, "@", "Add a new person and/or his/her friends", "a", "glow", function() {
        var form, id, o, _i, _len, _ref;
        $(this).removeClass('glow');
        form = $("<form>").insertAfter(this).submit(function(event) {
          var load_friends, load_self, v;
          event.preventDefault();
          v = $(this).find('input[type=text]').val().toLowerCase().replace("@", "");
          if (/[^a-z_0-9]/g.test(v)) {
            return alert('Not a valid twitter handle. Use letters, numbers and underscores only.');
          } else {
            load_friends = $(this).find('input[name=friends]').attr('checked') != null;
            load_self = $(this).find('input[name=self]').attr('checked') != null;
            downloader.visual_insert = $(this).find('input[name=visual_insert]').attr('checked') != null;
            simulation.add_protagonist(v, load_friends, load_self);
            return $(this).remove();
          }
        });
        $("<input>").addClass("protagonist_adder").attr("type", "text").attr("placeholder", "@twitter_handle").appendTo(form).focus().keyup(function(event) {
          if (event.keyCode === 27) {
            return $(this).parent().remove();
          }
        });
        _ref = [
          {
            name: 'friends',
            text: 'Friends',
            "default": true
          }, {
            name: 'self',
            text: 'Self',
            "default": false
          }, {
            name: 'visual_insert',
            text: 'Insert tracer (cool but slow)',
            "default": true
          }
        ];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          o = _ref[_i];
          id = Math.round(Math.random() * 10000);
          id = "" + o.name + "_" + id;
          $("<input>").attr('name', o.name).attr('id', id).attr('value', '1').attr('checked', o["default"]).attr('type', 'checkbox').appendTo(form);
          $("<label>").attr('for', id).text(o.text).appendTo(form);
        }
        $("<input>").attr('type', 'submit').attr('value', 'Go!').appendTo(form);
        return $(form).find('input').blur(function() {
          var a;
          a = setTimeout(function() {
            if ($(form).find('input[type=text]').val().length === 0) {
              return $(form).remove();
            }
          }, 1000);
          return $(this).parent().data('on_form_blur_timeout', a);
        }).focus(function() {
          var a;
          a = $(this).parent().data('on_form_blur_timeout');
          if (a != null) {
            clearTimeout(a);
          }
          return $(this).parent().data('on_form_blur_timeout', null);
        });
      });
      try_cache = function(task, callback) {
        var url;
        if (task.name != null) {
          url = "/cache/userbyname/" + (task.name.toLowerCase());
        } else {
          url = "/cache/user/" + task.id;
        }
        return $.ajax({
          url: url,
          dataType: 'json',
          type: 'GET',
          error: function(xhr, textstatus, errorthrown) {
            if (xhr.status === 404) {
              return callback(null, null);
            } else {
              console.log("Server cache does not respond. This is bad...");
              return callback(null, null);
            }
          },
          success: function(result, a, xhr) {
            var f;
            f = result[0];
            f["protected"] = !(f["protected"] === 'false' || f["protected"] === false);
            return callback(f);
          }
        });
      };
      try_twitter = function(object, get_friends, task, callback) {
        var base_url;
        if (get_friends && (object != null) && (object["protected"] === 'true' || object["protected"] === true)) {
          object.friends = [];
          $.post('/cache/post/user/' + object.id, {
            data: JSON.stringify(object)
          });
          return callback(object, null);
        }
        if (_this.no_more_twitter_count > 4) {
          return callback(null, object);
        }
        base_url = 'http://api.twitter.com/1';
        if (get_friends) {
          if (!((object != null) && (object.id != null))) {
            return callback(null, 'Should not look get friends without user id');
          }
          task.twitter_url = "" + base_url + "/friends/ids.json?cursor=-1&user_id=" + object.id;
        } else if (task.name != null) {
          task.twitter_url = "" + base_url + "/users/lookup.json?screen_name=" + (task.name.toLowerCase());
        } else {
          task.twitter_url = "" + base_url + "/users/lookup.json?user_id=" + task.id;
        }
        return $.ajax({
          type: 'POST',
          url: task.twitter_url,
          dataType: "jsonp",
          success: function(r, a, xhr) {
            var f;
            _this.no_more_twitter_count = 0;
            if (get_friends) {
              object.friends = r;
              $.post('/cache/post/user/' + object.id, {
                data: JSON.stringify(object)
              });
              return callback(object, null);
            } else {
              f = r[0];
              f["protected"] = !(f["protected"] === 'false' || f["protected"] === false);
              return callback(null, f);
            }
          },
          timeout: 4000,
          error: function() {
            _this.no_more_twitter_count += 1;
            return callback(null, object);
          }
        });
      };
      try_pipes = function(object, get_friends, task, callback) {
        if (_this.no_more_pipes) {
          return callback(null, object);
        }
        return $.ajax({
          type: 'POST',
          data: {
            _id: '81263ca2954c525a92e8ebe02b9c5a82',
            _render: 'json',
            url: task.twitter_url
          },
          url: 'http://pipes.yahoo.com/pipes/pipe.run',
          dataType: "jsonp",
          jsonp: "_callback",
          success: function(r, a, xhr) {
            if (r['count'] > 0) {
              r = r['value']['items'];
              if (get_friends) {
                object.friends = r;
                $.post('/cache/user/' + object.id, {
                  data: JSON.stringify(object)
                });
                return callback(object, null);
              } else {
                return callback(null, r[0]);
              }
            } else {
              return callback(null, object);
            }
          },
          timeout: 2000,
          error: function() {
            _this.no_more_pipes = true;
            return callback(null, object);
          }
        });
      };
      this.q = async.queue(function(task, callback) {
        return setTimeout(function() {
          return async.waterfall([
            function(callback) {
              return try_cache(task, callback);
            }, function(object, callback) {
              return try_twitter(object, false, task, callback);
            }, function(object, callback) {
              return try_twitter(object, true, task, callback);
            }, function(object, callback) {
              return callback(null, "Could not complete result");
            }
          ], function(result, error) {
            downloader.status.update();
            if (error != null) {
              return callback({
                error: error
              });
            } else {
              return callback({
                result: result
              });
            }
          });
        }, 10);
      }, 1);
      this.q.drain = function() {
        return setTimeout(function() {
          if (simulation.lastclicked) {
            simulation.lastclicked.click();
          }
          simulation.lastclicked = null;
          if (_this.failed_downloads > 0) {
            alert("Done loading users. However, we failed to load " + _this.failed_downloads + " friends, probably due to twitter rate limiting. Come back in one hour to load more users.");
          }
          _this.failed_downloads = 0;
          _this.no_more_twitter = false;
          _this.no_more_twitter_count = 0;
          return _this.no_more_pipes = false;
        }, 1000);
      };
      this.status = new DownloadStatus(this, this.btn.div.parent());
    }

    return Downloader;

  })();

  $(function() {
    return window.downloader = new Downloader;
  });

}).call(this);
